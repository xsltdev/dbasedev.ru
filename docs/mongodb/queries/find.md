# Знакомство с методом find

Метод `find` используется в MongoDB для выполнения запросов. При выполнении запроса возвращается подмножество документов в коллекции, при этом документов может не быть вообще либо это может быть вся коллекция. Какие документы возвращаются, определяется первым аргументом метода, который представляет собой документ, определяющий критерии запроса.

Пустой документ запроса (т. е. `{}`) соответствует всему, что есть в коллекции. Если методу `find` не предоставлен документ запроса, по умолчанию используется `{}`. Например, строка

```
> db.c.find()
```

соответствует каждому документу в коллекции `c` (и возвращает эти документы в пакетном режиме).

Когда мы начинаем добавлять пары типа «ключ/значение» в документ запроса, мы начинаем ограничивать наш поиск. Для большинства типов это работает просто: числа соответствуют числам, логические значения соответствуют логическим значениям, а строки соответствуют строкам. Запросить простой тип так же просто, как указать значение, которое вы ищете. Например, чтобы найти все документы, где значение `age` равно `27`, можно добавить эту пару типа «ключ/значение» в документ запроса:

```
> db.users.find({"age" : 27})
```

Если у нас есть строка, которую мы хотим сопоставить, например ключ `username` и значение `joe`, мы используем эту пару:

```
> db.users.find({"username" : "joe"})
```

Можно объединить несколько условий, добавив больше пар типа «ключ/значение» в документ запроса, который интерпретируется как «условие1 И условие2 И… И условиеN». Например, чтобы получить всех пользователей, которым `27` лет, с именем `joe`, можно выполнить следующий запрос:

```
> db.users.find({"username" : "joe", "age" : 27})
```

## Указываем, какие ключи нужно вернуть

Иногда вам не нужны все пары типа «ключ/значение» в возвращаемом документе. В этом случае можно передать второй аргумент методу `find` (или `findOne`), указывая нужные вам ключи. Это уменьшает как объем передаваемых данных, так и время и память, используемые для декодирования документов на стороне клиента.

Например, если у вас есть коллекция пользователей и вас интересуют только ключи `username` и `email`, можно вернуть лишь эти ключи с помощью следующего запроса:

```
> db.users.find({}, {"username" : 1, "email" : 1})
```

```js
{
"_id" : ObjectId("4ba0f0dfd22aa494fd523620"),
"username" : "joe",
"email" : "joe@example.com"
}
```

Как видно из предыдущего вывода, ключ `_id` возвращается по умолчанию, даже если он не запрашивается специально.

Вы также можете использовать этот второй параметр, чтобы исключить определенные пары типа «ключ/значение» из результатов запроса. Например, у вас могут быть документы с различными ключами, и единственное, что вы знаете, – это то, что вы ни за что не хотите возвращать ключ `fatal_weakness`:

```
> db.users.find({}, {"fatal_weakness" : 0})
```

Приведенный ниже код также может предотвратить возвращение `_id`:

```
> db.users.find({}, {"username" : 1, "_id" : 0})
```

```js
{
"username" : "joe",
}
```

## Ограничения

Есть некоторые ограничения на запросы. Значение документа запроса должно быть константой для базы данных. (Это может быть обычная переменная в вашем собственном коде.) То есть она не может ссылаться на значение другого ключа в документе. Например, если бы мы вели учет и у нас были бы ключи `in_stock` и `num_sold`, мы не могли бы сравнивать их значения с помощью следующего запроса:

```
> db.stock.find({"in_stock" : "this.num_sold"}) //Это не сработает;
```

Есть способы сделать это, но, как правило, вы будете получать лучшую производительность, слегка реструктурировав документ, поэтому «обычного» запроса будет достаточно. В этом примере мы могли бы использовать ключи `initial_stock` и `in_stock`. Затем каждый раз, когда кто-то покупает товар, мы уменьшаем значение ключа `in_stock` на единицу. Наконец, мы можем сделать простой запрос, чтобы проверить, каких товаров нет в наличии:

```
> db.stock.find({"in_stock" : 0})
```
