# COLLECT

Операция `COLLECT` может использоваться для группировки данных по одному или нескольким критериям группировки. Она также может использоваться для получения всех отдельных значений, подсчета частоты встречаемости значений и эффективного вычисления статистических свойств.

Оператор `COLLECT` удаляет все локальные переменные в текущей области видимости. После `COLLECT` доступны только переменные, введенные самим `COLLECT`.

## Синтаксис

Существует несколько вариантов синтаксиса для операций `COLLECT`:

<pre><code>COLLECT <em>variableName</em> = <em>expression</em>
COLLECT <em>variableName</em> = <em>expression</em> INTO <em>groupsVariable</em>
COLLECT <em>variableName</em> = <em>expression</em> INTO <em>groupsVariable</em> = <em>projectionExpression</em>
COLLECT <em>variableName</em> = <em>expression</em> INTO <em>groupsVariable</em> KEEP <em>keepVariable</em>
COLLECT <em>variableName</em> = <em>expression</em> WITH COUNT INTO <em>countVariable</em>
COLLECT <em>variableName</em> = <em>expression</em> AGGREGATE variableName = <em>aggregateExpression</em>
COLLECT <em>variableName</em> = <em>expression</em> AGGREGATE variableName = <em>aggregateExpression</em> INTO <em>groupsVariable</em>
COLLECT AGGREGATE <em>variableName</em> = <em>aggregateExpression</em>
COLLECT AGGREGATE <em>variableName</em> = <em>aggregateExpression</em> INTO <em>groupsVariable</em>
COLLECT WITH COUNT INTO <em>countVariable</em></code></pre>

Все варианты могут опционально заканчиваться предложением `OPTIONS { ... }`.

## Синтаксис группировки

Первая синтаксическая форма `COLLECT` группирует результат только по определенным групповым критериям, указанным в _выражении_. Для дальнейшей обработки результатов, полученных с помощью `COLLECT`, вводится новая переменная (заданная _variableName_). Эта переменная содержит значение группы.

Вот пример запроса, который находит отдельные значения в `u.city` и делает их доступными в переменной `city`:

<!-- 0001.part.md -->

```aql
FOR u IN users
  COLLECT city = u.city
  RETURN {
    "city" : city
  }
```

<!-- 0002.part.md -->

Вторая форма делает то же самое, что и первая, но дополнительно вводит переменную (заданную _groupsVariable_), которая содержит все элементы, попавшие в группу. Это работает следующим образом: Переменная _groupsVariable_ - это массив, содержащий столько элементов, сколько их в группе. Каждый член этого массива представляет собой объект JSON, в котором значение каждой переменной, определенной в запросе AQL, привязано к соответствующему атрибуту. Обратите внимание, что при этом учитываются все переменные, определенные до оператора `COLLECT`, но не те, которые находятся на верхнем уровне (вне любого `FOR`), если только оператор `COLLECT` сам не находится на верхнем уровне, в этом случае учитываются все переменные. Кроме того, обратите внимание, что оптимизатор может перемещать операторы `LET` из операторов `FOR` для повышения производительности.

<!-- 0003.part.md -->

```aql
FOR u IN users
  COLLECT city = u.city INTO groups
  RETURN {
    "city" : city,
    "usersInCity" : groups
  }
```

<!-- 0004.part.md -->

В приведенном выше примере массив `users` будет сгруппирован по атрибуту `city`. В результате будет получен новый массив документов, с одним элементом для каждого отдельного значения `u.city`. Элементы исходного массива (здесь: `users`) для каждого города доступны в переменной `groups`. Это происходит благодаря предложению `INTO`.

`COLLECT` также позволяет указать несколько групповых критериев. Отдельные групповые критерии могут быть разделены запятыми:

<!-- 0005.part.md -->

```aql
FOR u IN users
  COLLECT country = u.country, city = u.city INTO groups
  RETURN {
    "country" : country,
    "city" : city,
    "usersInCity" : groups
  }
```

<!-- 0006.part.md -->

В приведенном выше примере массив `users` сгруппирован сначала по стране, а затем по городу, и для каждой отдельной комбинации страны и города будут возвращены пользователи.

## Отказ от устаревших переменных

Третья форма `COLLECT` позволяет переписать содержимое _groupsVariable_ с помощью произвольной _projectionExpression_:

<!-- 0007.part.md -->

```aql
FOR u IN users
  COLLECT country = u.country, city = u.city INTO groups = u.name
  RETURN {
    "country" : country,
    "city" : city,
    "userNames" : groups
  }
```

<!-- 0008.part.md -->

В приведенном выше примере только _projectionExpression_ является `u.name`. Поэтому только этот атрибут копируется в _groupsVariable_ для каждого документа. Это, вероятно, гораздо эффективнее, чем копирование всех переменных из области видимости в _groupsVariable_, как это произошло бы без _projectionExpression_.

Выражение, следующее за `INTO`, также может быть использовано для произвольных вычислений:

<!-- 0009.part.md -->

```aql
FOR u IN users
  COLLECT country = u.country, city = u.city INTO groups = {
    "name" : u.name,
    "isActive" : u.status == "active"
  }
  RETURN {
    "country" : country,
    "city" : city,
    "usersInCity" : groups
  }
```

<!-- 0010.part.md -->

`COLLECT` также предоставляет необязательное условие `KEEP`, которое можно использовать для управления тем, какие переменные будут скопированы в переменную, созданную `INTO`. Если условие `KEEP` не указано, все переменные из области видимости будут скопированы в качестве податрибутов в _groupsVariable_. Это безопасно, но может отрицательно сказаться на производительности, если в области видимости много переменных или переменные содержат большие объемы данных.

В следующем примере переменные, которые копируются в _groupsVariable_, ограничиваются только `name`. Переменные `u` и `someCalculation`, также присутствующие в области видимости, не будут скопированы в _groupsVariable_, поскольку они не указаны в предложении `KEEP`:

<!-- 0011.part.md -->

```aql
FOR u IN users
  LET name = u.name
  LET someCalculation = u.value1 + u.value2
  COLLECT city = u.city INTO groups KEEP name
  RETURN {
    "city" : city,
    "userNames" : groups[*].name
  }
```

<!-- 0012.part.md -->

`KEEP` действует только в сочетании с `INTO`. В предложении `KEEP` можно использовать только правильные имена переменных. `KEEP` поддерживает указание нескольких имен переменных.

## Вычисление длины группы

`COLLECT` также предоставляет специальное предложение `WITH COUNT`, которое может быть использовано для эффективного определения количества членов группы.

В простейшей форме возвращается только количество элементов, попавших в `COLLECT`:

<!-- 0013.part.md -->

```aql
FOR u IN users
  COLLECT WITH COUNT INTO length
  RETURN length
```

<!-- 0014.part.md -->

Вышеприведенный вариант эквивалентен, но менее эффективен, чем:

<!-- 0015.part.md -->

```aql
RETURN LENGTH(users)
```

<!-- 0016.part.md -->

Предложение `WITH COUNT` также можно использовать для эффективного подсчета количества элементов в каждой группе:

<!-- 0017.part.md -->

```aql
FOR u IN users
  COLLECT age = u.age WITH COUNT INTO length
  RETURN {
    "age" : age,
    "count" : length
  }
```

!!!info ""

    Предложение `WITH COUNT` можно использовать только вместе с предложением `INTO`.

## Агрегация

Оператор `COLLECT` можно использовать для агрегирования данных по группам. Чтобы определить только длину группы, можно использовать вариант `WITH COUNT INTO` оператора `COLLECT`, как описано ранее.

Для других агрегаций можно запустить агрегатные функции на результатах `COLLECT`:

<!-- 0019.part.md -->

```aql
FOR u IN users
  COLLECT ageGroup = FLOOR(u.age / 5) * 5 INTO g
  RETURN {
    "ageGroup" : ageGroup,
    "minAge" : MIN(g[*].u.age),
    "maxAge" : MAX(g[*].u.age)
  }
```

<!-- 0020.part.md -->

Однако вышеописанный способ требует хранения всех значений группы во время операции сбора для всех групп, что может быть неэффективным.

Специальный вариант `AGGREGATE` функции `COLLECT` позволяет создавать агрегатные значения постепенно во время операции сбора и поэтому часто является более эффективным.

При использовании варианта `AGGREGATE` приведенный выше запрос становится:

<!-- 0021.part.md -->

```aql
FOR u IN users
  COLLECT ageGroup = FLOOR(u.age / 5) * 5
  AGGREGATE minAge = MIN(u.age), maxAge = MAX(u.age)
  RETURN {
    ageGroup,
    minAge,
    maxAge
  }
```

<!-- 0022.part.md -->

Ключевое слово `AGGREGATE` может использоваться только после ключевого слова `COLLECT`. Если оно используется, то должно следовать непосредственно за объявлением ключей группировки. Если ключи группировки не используются, оно должно следовать непосредственно за ключевым словом `COLLECT`:

<!-- 0023.part.md -->

```aql
FOR u IN users
  COLLECT AGGREGATE minAge = MIN(u.age), maxAge = MAX(u.age)
  RETURN {
    minAge,
    maxAge
  }
```

<!-- 0024.part.md -->

В правой части каждого присваивания `AGGREGATE` допускаются только определенные выражения:

- на верхнем уровне агрегированное выражение должно быть вызовом одной из поддерживаемых функций агрегирования:

  - `LENGTH()` / `COUNT()`
  - `MIN()`
  - `MAX()`
  - `SUM()`
  - `AVERAGE()` / `AVG()`
  - `STDDEV_POPULATION()` / `STDDEV()`
  - `STDDEV_SAMPLE()`
  - `VARIANCE_POPULATION()` / `VARIANCE()`
  - `VARIANCE_SAMPLE()`
  - `UNIQUE()`
  - `SORTED_UNIQUE()`
  - `COUNT_DISTINCT()` / `COUNT_UNIQUE()`
  - `BIT_AND()`
  - `BIT_OR()`
  - `BIT_XOR()`

- агрегированное выражение не должно ссылаться на переменные, введенные самим `COLLECT`.

## `COLLECT` против `RETURN DISTINCT`

Для того чтобы сделать набор результатов уникальным, можно использовать либо `COLLECT`, либо `RETURN DISTINCT`.

<!-- 0025.part.md -->

```aql
FOR u IN users
  RETURN DISTINCT u.age
```

<!-- 0026.part.md -->

<!-- 0027.part.md -->

```aql
FOR u IN users
  COLLECT age = u.age
  RETURN age
```

<!-- 0028.part.md -->

За кулисами оба варианта создают _CollectNode_. Однако они используют разные реализации `COLLECT`, которые имеют разные свойства:

- `RETURN DISTINCT` **сохраняет порядок результатов**, но он ограничен одним значением.

- `COLLECT` **изменяет порядок результатов** (отсортированный или неопределенный), но поддерживает несколько значений и является более гибким, чем `RETURN DISTINCT`.

Помимо сложных возможностей группировки и агрегации, `COLLECT` позволяет поместить операцию `LIMIT` перед `RETURN`, чтобы потенциально остановить операцию `COLLECT` раньше времени.

## Параметры `COLLECT`

### `method`

Существует два варианта `COLLECT`, которые оптимизатор может выбрать: вариант _sorted_ и вариант _hash_. Опция `method` может быть использована в операторе `COLLECT`, чтобы сообщить оптимизатору о предпочтительном методе, `"sorted"` или `"hash"`.

<!-- 0029.part.md -->

```aql
COLLECT ... OPTIONS { method: "sorted" }
```

<!-- 0030.part.md -->

Если метод не указан пользователем, то оптимизатор создаст план, использующий метод _sorted_, и дополнительный план, использующий метод _hash_, если оператор `COLLECT` удовлетворяет его требованиям.

Если метод явно установлен в _sorted_, то оптимизатор всегда будет использовать _sorted_ вариант `COLLECT` и даже не создаст план с использованием _hash_ варианта. Если он явно установлен в _hash_, то оптимизатор будет создавать план с использованием метода _hash_ **только если оператор `COLLECT` соответствует требованиям**. Не все операторы `COLLECT` могут использовать метод _hash_, в частности, операторы с клаузулой `INTO` не подходят. Если оператор `COLLECT` соответствует требованиям, то будет только один план, использующий метод _hash_. В противном случае оптимизатор по умолчанию будет использовать метод _sorted_.

Метод _sorted_ требует, чтобы его входные данные были отсортированы по групповым критериям, указанным в предложении `COLLECT`. Для обеспечения корректности результата оптимизатор автоматически вставит в запрос операцию `SORT` перед оператором `COLLECT`. В дальнейшем оптимизатор может отказаться от этой операции `SORT`, если для групповых критериев имеется отсортированный индекс.

Если оператор `COLLECT` претендует на использование варианта _hash_, оптимизатор создаст для него дополнительный план в начале фазы планирования. В этом плане перед оператором `COLLECT` не будет добавляться дополнительный оператор `SORT`. Это связано с тем, что _hash_ вариант `COLLECT` не требует отсортированного ввода. Вместо этого после `COLLECT` будет добавлен оператор `SORT` для сортировки его вывода. Этот оператор `SORT` может быть снова оптимизирован на последующих этапах.

Если порядок сортировки в `COLLECT` не имеет значения для пользователя, добавление дополнительной инструкции `SORT null` после `COLLECT` позволит оптимизатору полностью удалить сортировку:

<!-- 0031.part.md -->

```aql
FOR u IN users
  COLLECT age = u.age
  SORT null  /* note: will be optimized away */
  RETURN age
```

<!-- 0032.part.md -->

Какой вариант `COLLECT` используется оптимизатором, если явно не задан предпочтительный метод, зависит от оценок затрат оптимизатора. Созданные планы с различными вариантами `COLLECT` будут проходить через обычный конвейер оптимизации. В итоге оптимизатор, как обычно, выберет план с наименьшей оценкой общей стоимости.

В целом, _сортированный_ вариант `COLLECT` следует предпочесть в тех случаях, когда в групповых критериях присутствует сортированный индекс. В этом случае оптимизатор может исключить операцию `SORT` перед `COLLECT`, так что никакого `SORT` не останется.

Если в критериях группы нет отсортированного индекса, то предварительная сортировка, требуемая вариантом _sorted_, может оказаться дорогостоящей. В этом случае, скорее всего, оптимизатор предпочтет _hash_ вариант `COLLECT`, который не требует сортировки входных данных.

Какой вариант `COLLECT` будет использоваться на самом деле, можно выяснить, посмотрев на план выполнения запроса, в частности, на комментарий _CollectNode_:

<!-- 0033.part.md -->

```aql
Execution plan:
 Id   NodeType                  Est.   Comment
  1   SingletonNode                1   * ROOT
  2   EnumerateCollectionNode      5     - FOR doc IN coll   /* full collection scan, projections: `name` */
  3   CalculationNode              5       - LET #2 = doc.`name`   /* attribute expression */   /* collections used: doc : coll */
  4   CollectNode                  5       - COLLECT name = #2   /* hash */
  6   SortNode                     5       - SORT name ASC   /* sorting strategy: standard */
  5   ReturnNode                   5       - RETURN name
```

<!-- 0034.part.md -->

<!-- 0035.part.md -->
