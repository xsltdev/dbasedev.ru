# REMOVE

Ключевое слово `REMOVE` может быть использовано для удаления документов из коллекции.

Каждая операция `REMOVE` ограничена одной коллекцией, и имя коллекции не должно быть динамическим. В одном запросе AQL допускается только один оператор `REMOVE` для одной коллекции, и за ним не могут следовать операции чтения или записи, которые обращаются к той же коллекции, операции обхода или функции AQL, которые могут читать документы.

## Синтаксис

Синтаксис операции удаления следующий:

<pre><code>REMOVE <em>keyExpression</em> IN <em>collection</em></code></pre>

Опционально он может заканчиваться предложением `OPTIONS { ... }`.

`collection` должно содержать имя коллекции, из которой нужно удалить документы. `keyExpression` должно быть выражением, содержащим идентификатор документа. Это может быть либо строка (которая затем должна содержать ключ документа), либо документ, который должен содержать атрибут `_key`.

Таким образом, следующие запросы эквивалентны:

<!-- 0001.part.md -->

```aql
FOR u IN users
  REMOVE { _key: u._key } IN users
```

<!-- 0002.part.md -->

<!-- 0003.part.md -->

```aql
FOR u IN users
  REMOVE u._key IN users
```

<!-- 0004.part.md -->

<!-- 0005.part.md -->

```aql
FOR u IN users
  REMOVE u IN users
```

<!-- 0006.part.md -->

Операция remove может удалять произвольные документы, и эти документы не обязательно должны быть идентичны тем, которые были получены предшествующим оператором `FOR`:

<!-- 0007.part.md -->

```aql
FOR i IN 1..1000
  REMOVE { _key: CONCAT('test', i) } IN users
```

<!-- 0008.part.md -->

<!-- 0009.part.md -->

```aql
FOR u IN users
  FILTER u.active == false
  REMOVE { _key: u._key } IN backup
```

<!-- 0010.part.md -->

Можно удалить и отдельный документ, используя строку ключа документа или документ с атрибутом `_key`:

<!-- 0011.part.md -->

```aql
REMOVE 'john' IN users
```

<!-- 0012.part.md -->

<!-- 0013.part.md -->

```aql
LET doc = DOCUMENT('users/john')
REMOVE doc IN users
```

<!-- 0014.part.md -->

Применяется ограничение на одну операцию удаления в запросе и коллекции. Следующий запрос вызывает ошибку _доступ после модификации данных_ из-за третьей операции удаления:

<!-- 0015.part.md -->

```aql
REMOVE 'john' IN users
REMOVE 'john' IN backups // OK, different collection
REMOVE 'mary' IN users   // Error, users collection again
```

<!-- 0016.part.md -->

## Параметры запроса

### `ignoreErrors`

`ignoreErrors` можно использовать для подавления ошибок запроса, которые могут возникнуть при попытке удалить несуществующие документы. Например, следующий запрос будет неудачным, если один из удаляемых документов не существует:

<!-- 0017.part.md -->

```aql
FOR i IN 1..1000
  REMOVE { _key: CONCAT('test', i) } IN users
```

<!-- 0018.part.md -->

Указав опцию запроса `ignoreErrors`, эти ошибки можно подавить, чтобы запрос завершился:

<!-- 0019.part.md -->

```aql
FOR i IN 1..1000
  REMOVE { _key: CONCAT('test', i) } IN users OPTIONS { ignoreErrors: true }
```

<!-- 0020.part.md -->

### `waitForSync`

Чтобы убедиться, что данные были записаны на диск при возврате запроса, существует опция запроса `waitForSync`:

<!-- 0021.part.md -->

```aql
FOR i IN 1..1000
  REMOVE { _key: CONCAT('test', i) } IN users OPTIONS { waitForSync: true }
```

<!-- 0022.part.md -->

### `ignoreRevs`

Чтобы случайно не удалить документы, которые были обновлены с момента последнего извлечения, вы можете использовать опцию `ignoreRevs`, чтобы либо позволить ArangoDB сравнивать значения `_rev` и добиваться успеха, только если они совпадают, либо позволить ArangoDB игнорировать их (по умолчанию):

<!-- 0023.part.md -->

```aql
FOR i IN 1..1000
  REMOVE { _key: CONCAT('test', i), _rev: "1287623" } IN users OPTIONS { ignoreRevs: false }
```

<!-- 0024.part.md -->

### `exclusive`

Движок RocksDB не требует блокировок на уровне коллекции. Различные операции записи в одну и ту же коллекцию не блокируют друг друга, если нет конфликтов _запись-запись_ на одних и тех же документах. С точки зрения разработки приложений может быть желательным иметь исключительный доступ на запись в коллекции, чтобы упростить разработку. Обратите внимание, что записи не блокируют чтения в RocksDB. Исключительный доступ также может ускорить запросы на модификацию, поскольку мы избегаем проверки конфликтов.

Используйте опцию `exclusive` для достижения этого эффекта на основе каждого запроса:

<!-- 0025.part.md -->

```aql
FOR doc IN collection
  REPLACE doc._key
  WITH { replaced: true }
  OPTIONS { exclusive: true }
```

<!-- 0026.part.md -->

### `refillIndexCaches`

Удалять ли существующие записи из кэша граней в памяти и пополнять его другими гранями, если документы граней удаляются.

<!-- 0027.part.md -->

```aql
REMOVE { _key: "123" } IN edgeColl
  OPTIONS { refillIndexCaches: true }
```

<!-- 0028.part.md -->

## Возвращение удаленных документов

Удаленные документы также могут быть возвращены запросом. В этом случае за оператором `REMOVE` должен следовать оператор `RETURN` (допускаются также промежуточные операторы `LET`).`REMOVE` вводит псевдо-значение `OLD` для ссылки на удаленные документы:

<!-- 0029.part.md -->

```aql
REMOVE keyExpression IN collection options RETURN OLD
```

<!-- 0030.part.md -->

Ниже приведен пример использования переменной с именем `removed` для регистрации удаленных документов. Для каждого удаленного документа будет возвращен ключ документа.

<!-- 0031.part.md -->

```aql
FOR u IN users
  REMOVE u IN users
  LET removed = OLD
  RETURN removed._key
```

<!-- 0032.part.md -->

## Транзакционность

На одном сервере удаление документов выполняется транзакционно по принципу "все или ничего".

Если используется движок RocksDB и включены промежуточные фиксации, запрос может выполнять промежуточные фиксации транзакций в случае, если запущенная транзакция (AQL-запрос) достигнет заданных пороговых значений размера. В этом случае операции запроса, выполненные до сих пор, будут зафиксированы и не будут откатаны в случае последующего отмены/отката. Это поведение можно контролировать, изменяя настройки промежуточной фиксации для движка RocksDB.

Для коллекций с шардированием вся операция запроса и/или удаления может не быть транзакционной, особенно если она затрагивает разные шарды и/или DB-серверы.

<!-- 0033.part.md -->
