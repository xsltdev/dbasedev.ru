# INSERT

Ключевое слово `INSERT` может быть использовано для вставки новых документов в коллекцию.

Каждая операция `INSERT` ограничена одной коллекцией, и имя коллекции не должно быть динамическим. В одном AQL-запросе допускается только один оператор `INSERT` для одной коллекции, и за ним не могут следовать операции чтения или записи, которые обращаются к той же коллекции, операции обхода или AQL-функции, которые могут читать документы.

## Синтаксис

Синтаксис операции вставки следующий:

<pre><code>INSERT <em>document</em> INTO <em>collection</em></code></pre>

Опционально он может заканчиваться предложением `OPTIONS { ... }`.

!!!tip ""

    Ключевое слово `IN` допускается вместо `INTO` и имеет то же значение.

`collection` должно содержать имя коллекции, в которую должны быть вставлены документы. `document` - это документ, который должен быть вставлен, и он может содержать или не содержать атрибут `_key`. Если атрибут `_key` не указан, ArangoDB автоматически сгенерирует значение для атрибута `_key`. При вставке документа также автоматически генерируется номер ревизии документа.

<!-- 0001.part.md -->

```aql
FOR i IN 1..100
  INSERT { value: i } INTO numbers
```

<!-- 0002.part.md -->

Операция вставки также может быть выполнена без цикла `FOR` для вставки одного документа:

<!-- 0003.part.md -->

```aql
INSERT { value: 1 } INTO numbers
```

<!-- 0004.part.md -->

При вставке в edge collection обязательно указывать атрибуты `_from` и `_to` в документе:

<!-- 0005.part.md -->

```aql
FOR u IN users
  FOR p IN products
    FILTER u._key == p.recommendedBy
    INSERT { _from: u._id, _to: p._id } INTO recommendations
```

<!-- 0006.part.md -->

## Параметры запроса

Ключевое слово `OPTIONS`, за которым следует объект с параметрами запроса, может быть опционально предоставлено в операции `INSERT`.

### `ignoreErrors`

`ignoreErrors` можно использовать для подавления ошибок запроса, которые могут возникнуть при нарушении ограничений уникального ключа:

<!-- 0007.part.md -->

```aql
FOR i IN 1..1000
  INSERT {
    _key: CONCAT('test', i),
    name: "test",
    foobar: true
  } INTO users OPTIONS { ignoreErrors: true }
```

<!-- 0008.part.md -->

### `waitForSync`

Чтобы убедиться, что данные будут долговечными при возврате запроса вставки, существует опция запроса `waitForSync`:

<!-- 0009.part.md -->

```aql
FOR i IN 1..1000
  INSERT {
    _key: CONCAT('test', i),
    name: "test",
    foobar: true
  } INTO users OPTIONS { waitForSync: true }
```

<!-- 0010.part.md -->

### `overwrite`

!!!info ""

    Опция `overwrite` устарела и заменена `overwriteMode`.

Если вы хотите заменить существующие документы документами с тем же ключом, существует опция запроса `overwrite`. Это позволит вам безопасно заменить документы вместо того, чтобы выдать ошибку "unique constraint violated error":

<!-- 0011.part.md -->

```aql
FOR i IN 1..1000
  INSERT {
    _key: CONCAT('test', i),
    name: "test",
    foobar: true
  } INTO users OPTIONS { overwrite: true }
```

<!-- 0012.part.md -->

### `overwriteMode`

Для дальнейшего контроля поведения INSERT при нарушении уникальных ограничений первичного индекса существует опция `overwriteMode`. Она предлагает следующие режимы:

- `"ignore"`: если документ с указанным значением `_key` уже существует, ничего не будет сделано и операция записи не будет выполнена. Операция вставки в этом случае возвращает успех. Этот режим не поддерживает возврат старой версии документа. Использование `RETURN OLD` приведет к ошибке разбора, так как не будет возвращена старая версия. `RETURN NEW` вернет документ только в том случае, если он был вставлен. Если документ уже существовал, `RETURN NEW` вернет `null`.
- `"replace"`: если документ с указанным значением `_key` уже существует, он будет перезаписан указанным значением документа. Этот режим также будет использоваться, если режим перезаписи не указан, но флаг `overwrite` установлен в `true`.
- `update`: если документ с указанным значением `_key` уже существует, он будет исправлен (частично обновлен) указанным значением документа.
- `"conflict"`: если документ с указанным значением `_key` уже существует, вернуть ошибку нарушения уникального ограничения, чтобы операция вставки завершилась неудачно. Это также поведение по умолчанию в случае, если режим перезаписи не установлен, а флаг `overwrite` равен `false` или не установлен.

Основное применение вставки документов с режимом перезаписи `ignore` заключается в том, чтобы убедиться, что определенные документы существуют самым дешевым возможным способом. В случае если целевой документ уже существует, режим `ignore` является наиболее эффективным, поскольку он не будет извлекать существующий документ из хранилища и не будет записывать в него никаких обновлений.

При использовании режима перезаписи `update` опции `keepNull` и `mergeObjects` управляют тем, как выполняется обновление. См. раздел [Операция UPDATE](update.md).

<!-- 0013.part.md -->

```aql
FOR i IN 1..1000
  INSERT {
    _key: CONCAT('test', i),
    name: "test",
    foobar: true
  } INTO users OPTIONS { overwriteMode: "update", keepNull: true, mergeObjects: false }
```

<!-- 0014.part.md -->

### `exclusive`.

Движок RocksDB не требует блокировок на уровне коллекции. Различные операции записи в одну и ту же коллекцию не блокируют друг друга, если нет конфликтов _запись-запись_ на одних и тех же документах. С точки зрения разработки приложений может быть желательным иметь исключительный доступ на запись в коллекции, чтобы упростить разработку. Обратите внимание, что записи не блокируют чтения в RocksDB. Исключительный доступ также может ускорить запросы на модификацию, поскольку мы избегаем проверки конфликтов.

Используйте опцию `exclusive` для достижения этого эффекта на основе каждого запроса:

<!-- 0015.part.md -->

```aql
FOR doc IN collection
  INSERT { myval: doc.val + 1 } INTO users
  OPTIONS { exclusive: true }
```

<!-- 0016.part.md -->

### `refillIndexCaches`

Добавлять ли новые записи в кэш границ в памяти при вставке документов границ.

<!-- 0017.part.md -->

```aql
INSERT { _from: "vert/A", _to: "vert/B" } INTO coll
  OPTIONS { refillIndexCaches: true }
```

<!-- 0018.part.md -->

## Возврат вставленных документов

Вставленные документы также могут быть возвращены запросом. В этом случае оператор `INSERT` может быть оператором `RETURN` (допускаются также промежуточные операторы `LET`). Для ссылки на вставленные документы оператор `INSERT` вводит псевдо-значение `NEW`.

Документы, содержащиеся в `NEW`, будут содержать все атрибуты, даже те, которые автоматически генерируются базой данных (например, `_id`, `_key`, `_rev`).

<!-- 0019.part.md -->

```aql
INSERT document INTO collection RETURN NEW
```

<!-- 0020.part.md -->

Ниже приведен пример с использованием переменной `inserted` для возврата вставленных документов. Для каждого вставленного документа возвращается ключ документа:

<!-- 0021.part.md -->

```aql
FOR i IN 1..100
  INSERT { value: i }
  INTO users
  LET inserted = NEW
  RETURN inserted._key
```

<!-- 0022.part.md -->

## Транзакционность

На одном сервере операция вставки выполняется транзакционно по принципу "все или ничего".

Если используется движок RocksDB и включены промежуточные фиксации, запрос может выполнять промежуточные фиксации транзакций в случае, если запущенная транзакция (AQL-запрос) достигнет заданных пороговых значений размера. В этом случае операции запроса, выполненные до сих пор, будут зафиксированы и не будут откатаны в случае последующего прерывания/отката. Это поведение можно контролировать, изменяя настройки промежуточной фиксации для движка RocksDB.

Для коллекций с шардированием вся операция запроса и/или вставки может не быть транзакционной, особенно если в ней участвуют разные шарды и/или DB-серверы.

<!-- 0023.part.md -->
