# RETURN

Оператор `RETURN` можно использовать для получения результата запроса. Обязательно указывать оператор `RETURN` в конце каждого блока в запросе на выборку данных, иначе результат запроса будет неопределен. Использование `RETURN` на основном уровне в запросах на модификацию данных необязательно.

## Синтаксис

Общий синтаксис для `RETURN` следующий:

<pre><code>RETURN <em>expression</em></code></pre>

Существует также вариант `RETURN DISTINCT`.

Выражение, возвращаемое `RETURN`, создается для каждой итерации в блоке, в котором находится оператор `RETURN`. Это означает, что результатом оператора `RETURN` всегда является **массив**. Он включает в себя пустой массив, если ни один документ не соответствует запросу, и единственное возвращаемое значение, возвращаемое как массив с одним элементом.

Чтобы вернуть все элементы из текущего итерируемого массива без изменений, можно использовать следующую простую форму:

<pre><code>FOR <em>variableName</em> IN <em>expression</em>
  RETURN <em>variableName</em></code></pre>

Поскольку `RETURN` позволяет указать выражение, для вычисления элементов результата могут быть выполнены произвольные вычисления. Для вычислений могут быть использованы любые переменные, действующие в области видимости, в которой находится `RETURN`.

## Использование

Чтобы перебрать все документы коллекции _users_ и вернуть полные документы, вы можете написать:

<!-- 0001.part.md -->

```aql
FOR u IN users
  RETURN u
```

<!-- 0002.part.md -->

В каждой итерации цикла for-loop документ коллекции _users_ присваивается переменной _u_ и возвращается в этом примере в неизменном виде. Чтобы вернуть только один атрибут каждого документа, можно использовать другое выражение возврата:

<!-- 0003.part.md -->

```aql
FOR u IN users
  RETURN u.name
```

<!-- 0004.part.md -->

Или, чтобы вернуть несколько атрибутов, объект можно построить следующим образом:

<!-- 0005.part.md -->

```aql
FOR u IN users
  RETURN { name: u.name, age: u.age }
```

<!-- 0006.part.md -->

Примечание: `RETURN` закроет текущую область видимости и удалит все локальные переменные в ней. Это важно помнить при работе с [подзапросами](../fundamentals/subqueries.md).

Также поддерживаются [динамические имена атрибутов](../fundamentals/data-types.md):

<!-- 0007.part.md -->

```aql
FOR u IN users
  RETURN { [ u._id ]: u.age }
```

<!-- 0008.part.md -->

Документ _id_ каждого пользователя используется в качестве выражения для вычисления ключа атрибута в этом примере:

<!-- 0009.part.md -->

```json
[
  {
    "users/9883": 32
  },
  {
    "users/9915": 27
  },
  {
    "users/10074": 69
  }
]
```

<!-- 0010.part.md -->

Результат содержит один объект для каждого пользователя с одной парой ключ/значение. Обычно это нежелательно. Для получения единого объекта, который сопоставляет идентификаторы пользователей с возрастами, отдельные результаты должны быть объединены и возвращены с помощью другого `RETURN`:

<!-- 0011.part.md -->

```aql
RETURN MERGE(
  FOR u IN users
    RETURN { [ u._id ]: u.age }
)
```

<!-- 0012.part.md -->

<!-- 0013.part.md -->

```json
[
  {
    "users/10074": 69,
    "users/9883": 32,
    "users/9915": 27
  }
]
```

<!-- 0014.part.md -->

Следует помнить, что если ключевое выражение оценивает одно и то же значение несколько раз, только одна из пар ключ/значение с дублирующим именем сохранится [MERGE()](../functions/document.md). Чтобы избежать этого, можно обойтись без динамических имен атрибутов, использовать вместо них статические имена и возвращать все свойства документа в качестве значений атрибутов:

<!-- 0015.part.md -->

```aql
FOR u IN users
  RETURN { name: u.name, age: u.age }
```

<!-- 0016.part.md -->

<!-- 0017.part.md -->

```json
[
  {
    "name": "John Smith",
    "age": 32
  },
  {
    "name": "James Hendrix",
    "age": 69
  },
  {
    "name": "Katie Foster",
    "age": 27
  }
]
```

<!-- 0018.part.md -->

## `RETURN DISTINCT`

За `RETURN` по желанию может следовать ключевое слово `DISTINCT`. Ключевое слово `DISTINCT` обеспечивает уникальность значений, возвращаемых оператором `RETURN`:

<pre><code>FOR <em>variableName</em> IN <em>expression</em>
  RETURN DISTINCT <em>expression</em></code></pre>

`RETURN DISTINCT` не допускается на верхнем уровне запроса, если ему не предшествует цикл `FOR`.

Приведенный ниже пример возвращает `["foo", "bar", "baz"]`:

<!-- 0019.part.md -->

```aql
FOR value IN ["foo", "bar", "bar", "baz", "foo"]
  RETURN DISTINCT value
```

<!-- 0020.part.md -->

!!!tip ""

    `RETURN DISTINCT` не изменит порядок результатов, к которым он применяется, в отличие от [`COLLECT`](collect.md).

Если `DISTINCT` применяется к выражению, которое само является массивом или подзапросом, `DISTINCT` не делает значения в каждом результате массива или подзапроса уникальными, а гарантирует, что результат содержит только различные массивы или результаты подзапроса. Чтобы сделать результат массива или подзапроса уникальным, просто примените `DISTINCT` для массива или подзапроса.

Например, следующий запрос применит `DISTINCT` к результатам подзапроса, но не внутри подзапроса:

<!-- 0021.part.md -->

```aql
FOR what IN 1..2
  RETURN DISTINCT (
    FOR i IN [ 1, 2, 3, 4, 1, 3 ]
      RETURN i
  )
```

<!-- 0022.part.md -->

Здесь у нас будет цикл `FOR` с двумя итерациями, каждая из которых выполняет подзапрос. Здесь `DISTINCT` применяется к результатам двух подзапросов. Оба подзапроса возвращают одно и то же значение результата (то есть `[ 1, 2, 3, 4, 1, 3 ]`), поэтому после `DISTINCT` останется только одно вхождение значения `[ 1, 2, 3, 4, 1, 3 ]`:

<!-- 0023.part.md -->

```json
[[1, 2, 3, 4, 1, 3]]
```

<!-- 0024.part.md -->

Если целью является применение `DISTINCT` внутри подзапроса, его нужно переместить туда:

<!-- 0025.part.md -->

```aql
FOR what IN 1..2
  LET sub = (
    FOR i IN [ 1, 2, 3, 4, 1, 3 ]
      RETURN DISTINCT i
  )
  RETURN sub
```

<!-- 0026.part.md -->

В приведенном выше случае `DISTINCT` сделает результаты подзапроса уникальными, так что каждый подзапрос вернет уникальный массив значений (`[ 1, 2, 3, 4 ]`). Поскольку подзапрос выполняется дважды и на верхнем уровне нет `DISTINCT`, этот массив будет возвращен дважды:

<!-- 0027.part.md -->

```json
[
  [1, 2, 3, 4],
  [1, 2, 3, 4]
]
```

<!-- 0028.part.md -->

<!-- 0029.part.md -->
