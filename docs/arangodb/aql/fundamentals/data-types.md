# Типы данных

AQL поддерживает как _примитивные_ типы данных, состоящие ровно из одного значения, так и _составные_ типы данных, состоящие из нескольких значений. Доступны следующие типы:

|            Тип данных | Описание                                                                |
| --------------------: | ----------------------------------------------------------------------- |
|              **null** | Пустое значение, а также: отсутствие значения                           |
|           **boolean** | Логическое значение истинности с возможными значениями `false` и `true` |
|            **number** | Число со знаком, включая дробные (real)                                 |
|            **string** | Текстовое значение в кодировке UTF-8                                    |
|      **array** / list | Последовательность значений, на которые ссылаются их позиции            |
| **object** / document | Последовательность значений, на которые ссылаются их имена              |

## Примитивные типы

### Значение Null

Значение `null` может использоваться для представления пустого или отсутствующего значения. Оно отличается от нулевого числового значения (`null != 0`) и других _ложных_ значений (`false` или строки нулевой длины `""`). Он также известен как `nil` или `None` на других языках.

Система может вернуть `null` при отсутствии значения, например, если вы вызываете [функцию](../functions.md) с неподдерживаемыми значениями в качестве аргументов или пытаетесь получить доступ к несуществующему [атрибуту](document-data.md).

### Тип Boolean

Тип данных _Boolean_ имеет два возможных значения: `true` и `false`. Они представляют два значения истинности в логике и математике.

### Числовые литералы

Числовые литералы могут быть целыми числами или вещественными значениями (числа с плавающей запятой). При желании они могут быть подписаны символами `+` или `-`. Десятичная точка `.` используется в качестве разделителя для необязательной дробной части. Также поддерживается научная нотация (_E-нотация_).

```
  1
 +1
 42
 -1
-42
  1.23
-99.99
  0.5
   .5
 -4.87e103
 -4.87E103
```

Следующие обозначения недопустимы и вызовут синтаксическую ошибку:

```
 1.
01.23
00.23
00
```

Все числовые значения обрабатываются как 64-битные целые числа со знаком или 64-битные значения с плавающей запятой двойной точности внутри. Используемый внутренний формат с плавающей запятой — IEEE 754.

!!! warning ""

    При представлении любых числовых целых значений в JavaScript с помощью [пользовательских функций AQL](extending.md) числа, точность которых превышает 32 бита, преобразуются в значения с плавающей запятой, поэтому большие целые числа могут потерять некоторые биты точности. То же самое верно и при преобразовании числовых результатов AQL в JavaScript (например, при возврате их в Foxx).

Начиная с ArangoDB v3.7.7, числовые целые литералы также могут быть выражены как двоичные (по основанию 2) или шестнадцатеричные (по основанию 16) числовые литералы.

- рефикс для двоичных целочисленных литералов — `0b`, например. `0b10101110`.
- Префикс для литералов шестнадцатеричных целых чисел равен `0x`, например. `0xabcdef02`.

Двоичные и шестнадцатеричные целые литералы могут использоваться только для целых чисел без знака. Максимальное поддерживаемое значение для двоичных и шестнадцатеричных числовых литералов — 2<sup>32</sup> - 1, т. е. `0b11111111111111111111111111111111` (двоичное) или `0xffffffff` (шестнадцатеричное).

### Строковые литералы

Строковые литералы должны быть заключены в одинарные или двойные кавычки. Если используемый символ кавычки должен использоваться внутри строкового литерала, он должен быть экранирован с помощью символа обратной косой черты. Буквальный обратный слэш также должен быть экранирован с помощью обратной косой черты.

```aql
"yikes!"
"don't know"
"this is a \"quoted\" word"
"this is a longer string."
"the path separator on Windows is \\"

'yikes!'
'don\'t know'
'this is a "quoted" word'
'this is a longer string.'
'the path separator on Windows is \\'
```

Все строковые литералы должны иметь кодировку UTF-8. В настоящее время невозможно использовать произвольные двоичные данные, если они не закодированы в кодировке UTF-8. Обходной путь для использования двоичных данных — кодировать данные с помощью [Base64](https://ru.wikipedia.org/wiki/Base64) или других алгоритмов на стороне приложения перед сохранением и декодировать их на стороне приложения после извлечения.

## Составные типы

AQL поддерживает два составных типа:

- **array**: Композиция безымянных значений, каждое из которых доступно по своей позиции. Иногда называется _списком_.
- **object**: Композиция именованных значений, каждое из которых доступно по имени. _Документ_ — это объект верхнего уровня.

### Массивы / списки

Первый поддерживаемый составной тип — это тип массива (array). Массивы фактически представляют собой последовательности (безымянных/анонимных) значений. Доступ к отдельным элементам массива можно получить по их позициям (индексам). Порядок элементов в массиве важен.

_Объявление массива_ начинается с левой квадратной скобки `[` и заканчивается правой квадратной скобкой `]`. Объявление содержит ноль, одно или несколько _выражений_, разделенных друг от друга запятой `,`. Пробелы вокруг элементов в объявлении игнорируются, поэтому для форматирования можно использовать разрывы строк, позиции табуляции и пробелы.

В самом простом случае массив пуст и выглядит так:

```json
[]
```

Элементы массива могут быть любыми допустимыми значениями _выражений_. Поддерживается вложенность массивов.

```json
[true][(1, 2, 3)][(-99, "yikes!", [false, ["no"], []], 1)][
  ["fox", "marshal"]
]
```

Запятая после последнего элемента разрешена (появилось в версии 3.7.0):

```aql
[
  1,
  2,
  3, // завершающая запятая
]
```

Позже к отдельным значениям массива можно получить доступ по их позициям с помощью аксессора `[]`. Положение элемента, к которому осуществляется доступ, должно быть числовым значением. Позиции начинаются с `0`. Также можно использовать отрицательные значения индекса для доступа к значениям массива, начиная с конца массива. Это удобно, если длина массива неизвестна и требуется доступ к элементам в конце массива.

```aql
// доступ к 1-му элементу массива (элементы начинаются с индекса 0)
u.friends[0]

// получить доступ к третьему элементу массива
u.friends[2]

// получить доступ к последнему элементу массива
u.friends[-1]

// доступ к предпоследнему элементу массива
u.friends[-2]
```

### Объекты / Документы

Другой поддерживаемый составной тип — это тип объекта (или документа). Объекты представляют собой композицию от нуля до многих атрибутов. Каждый атрибут представляет собой пару имя/значение. Доступ к атрибутам объекта можно получить индивидуально по их именам. Этот тип данных также известен как словарь, карта, ассоциативный массив и другие названия.

Объявления объектов начинаются с левой фигурной скобки `{` и заканчиваются правой фигурной скобкой `}`. Объект содержит от нуля до многих объявлений атрибутов, разделенных друг от друга символом `,`. Пробелы вокруг элементов в объявлении игнорируются, поэтому для форматирования можно использовать разрывы строк, позиции табуляции и пробелы.

В простейшем случае объект пуст. Тогда его объявление будет таким:

```json
{}
```

Каждый атрибут в объекте представляет собой пару имя/значение. Имя и значение атрибута разделяются двоеточием `:`. Имя всегда является строкой, тогда как значение может быть любого типа, включая подобъекты.

Имя атрибута обязательно — в объекте не может быть анонимных значений. Он может быть указан как строка в кавычках или без кавычек:

```aql
{ name: … }    // без кавычек
{ 'name': … }  // в кавычках (апостроф / "одинарная кавычка")
{ "name": … }  // в кавычках (кавычка / "двойная кавычка")
```

Он должен быть заключен в кавычки, если он содержит пробелы, escape-последовательности или символы, отличные от букв ASCII (`a-z`, `A-Z`), цифр (`0-9`), символов подчеркивания (`_`) и знаков доллара (`$`). Первым символом должна быть буква, знак подчеркивания или знак доллара.

Если в качестве имени атрибута используется [ключевое слово](syntax.md), то имя атрибута должно быть заключено в кавычки или экранировано галочками или обратными кавычками:

```aql
{ return: … }    // ошибка, return - это ключевое слово!
{ 'return': … }  // в кавычках
{ "return": … }  // в кавычках
{ `return`: … }  // экранируется (backticks)
{ ´return´: … }  // экранируется (ticks)
```

Запятая после последнего элемента разрешена (появилось в версии 3.7.0):

```aql
{
  "a": 1,
  "b": 2,
  "c": 3, // завершающая запятая
}
```

Имена атрибутов также могут быть вычислены с использованием динамических выражений. Чтобы отличить обычные имена атрибутов от выражений имен атрибутов, вычисляемые имена атрибутов должны быть заключены в квадратные скобки `[ … ]`:

```aql
{ [ CONCAT("test/", "bar") ] : "someValue" }
```

Существует также сокращенная запись для атрибутов, которая удобна для простого возврата существующих переменных:

```aql
LET name = "Peter"
LET age = 42
RETURN { name, age }
```

Приведенное выше является сокращенным эквивалентом общей формы:

```aql
LET name = "Peter"
LET age = 42
RETURN { name: name, age: age }
```

В качестве значения атрибута можно использовать любое допустимое выражение. Это также означает, что вложенные объекты могут использоваться в качестве значений атрибутов:

```aql
{ name : "Peter" }
{ "name" : "Vanessa", "age" : 15 }
{ "name" : "John", likes : [ "Swimming", "Skiing" ], "address" : { "street" : "Cucumber lane", "zip" : "94242" } }
```

Позже к отдельным атрибутам объекта можно получить доступ по их именам с помощью точки `.`:

```aql
u.address.city.name
u.friends[0].name.first
```

Доступ к атрибутам также можно получить, используя квадратную скобку `[]`:

```aql
u["address"]["city"]["name"]
u["friends"][0]["name"]["first"]
```

В отличие от метода доступа точка, квадратные скобки позволяют использовать выражения:

```aql
LET attr1 = "friends"
LET attr2 = "name"
u[attr1][0][attr2][ CONCAT("fir", "st") ]
```

!!! info ""

    Если доступ к несуществующему атрибуту осуществляется тем или иным способом, результат будет `null` без ошибки или предупреждения.
